<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>StreamView Nexus Infinity</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root { 
            --bg: #000; --card: #111; --accent: #ff0050; --blue: #0095f6; --text: #fff; 
            --glass: rgba(255, 255, 255, 0.1); --border: #262626;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        /* IMPORTANT: allow scrolling on pc */
        body { background: var(--bg); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica; margin: 0; overflow: auto; height: 100vh; }

        /* AUTH GLASS EFFECT */
        #authOverlay { position: fixed; inset: 0; background: radial-gradient(circle at top, #1a1a1a, #000); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 25px; }
        .auth-card { background: var(--card); padding: 40px 30px; border-radius: 35px; width: 100%; max-width: 380px; text-align: center; border: 1px solid var(--border); box-shadow: 0 10px 40px rgba(0,0,0,0.8); }
        .auth-input { width: 100%; padding: 15px; margin: 10px 0; border-radius: 15px; border: 1px solid #333; background: #050505; color: white; font-size: 16px; transition: 0.3s; }
        .auth-input:focus { border-color: var(--blue); box-shadow: 0 0 10px rgba(0,149,246,0.3); }
        .auth-btn { width: 100%; padding: 16px; margin-top: 20px; border-radius: 15px; border: none; font-weight: 700; background: linear-gradient(45deg, var(--blue), #00d4ff); color: white; cursor: pointer; }

        /* HEADER & STORIES */
        .app-header { background: rgba(0,0,0,0.85); backdrop-filter: blur(20px); border-bottom: 0.5px solid var(--border); position: sticky; top: 0; z-index: 1000; }
        .top-nav { display: flex; justify-content: space-between; align-items: center; padding: 12px 20px; gap:12px; }
        .logo { font-size: 24px; font-weight: 900; background: linear-gradient(45deg, #f09433, #e6683c, #dc2743, #cc2366, #bc1888); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        .stories-bar { display: flex; gap: 15px; padding: 10px 15px; overflow-x: auto; scrollbar-width: none; }
        .story-ring { width: 68px; height: 68px; border-radius: 50%; padding: 3px; background: linear-gradient(45deg, #f9ed32, #ee2a7b, #002aff); flex-shrink: 0; cursor: pointer; }
        .story-pfp { width: 100%; height: 100%; border-radius: 50%; object-fit: cover; background: #111; border: 2px solid #000; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 22px; }

        /* Search UI */
        .search-wrap { display:flex; align-items:center; gap:8px; }
        #globalSearch { width: 260px; max-width:40vw; padding:10px 12px; border-radius: 12px; border:1px solid #333; background:#050505; color:white; }
        #searchResults { display:none; position: absolute; left:20px; right:20px; top:72px; z-index:12000; background: rgba(12,12,12,0.98); border:1px solid #222; border-radius:12px; max-height:380px; overflow:auto; padding:8px; box-shadow:0 10px 40px rgba(0,0,0,0.7); }
        .sr-item{padding:10px;border-radius:10px;margin:6px 4px;display:flex;gap:10px;align-items:center;cursor:pointer}
        .sr-item:hover{background:rgba(255,255,255,0.02)}

        /* STORY VIEWER MODAL */
        #storyViewer { position: fixed; inset: 0; background: #000; z-index: 10001; display: none; flex-direction: column; }
        .story-progress { display: flex; gap: 4px; padding: 10px; position: absolute; top: 0; width: 100%; }
        .prog-bg { background: rgba(255,255,255,0.3); height: 2px; flex: 1; border-radius: 2px; overflow: hidden; }
        .prog-fill { background: #fff; height: 100%; width: 0%; transition: width 0.1s linear; }
        .story-content { flex: 1; display: flex; align-items: center; justify-content: center; position: relative; }
        .story-content img { max-width: 100%; max-height: 100%; object-fit: contain; }
        .story-ui { position: absolute; top: 20px; left: 0; right: 0; padding: 15px; display: flex; align-items: center; gap: 10px; color: #fff; }

        /* PAGES */
        .page { display: none; width: 100%; min-height: calc(100vh - 175px); overflow-y: auto; scroll-behavior: smooth; }
        .active-page { display: block; animation: fadeIn 0.4s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* FEED */
        .video-card { margin-bottom: 20px; background: #000; border-bottom: 1px solid #111; padding-bottom:8px; border-radius:8px; overflow:hidden; }
        .video-card video { width: 100%; aspect-ratio: 16/9; display: block; background: #111; }
        .v-body { padding: 15px; display: flex; gap: 12px; align-items:center; }
        .avatar-v { width: 42px; height: 42px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; overflow: hidden; border: 1px solid #333; }
        .v-actions { display: flex; justify-content: space-between; padding: 10px 20px 20px; }
        .act-group { display: flex; gap: 20px; }
        .act-btn { background: none; border: none; color: #fff; font-size: 20px; cursor: pointer; transition: 0.2s; }
        .act-btn:active { transform: scale(0.8); }
        .active-l { color: var(--accent) !important; }

        /* STATS STYLE */
        .profile-stats { display: flex; justify-content: center; gap: 30px; margin: 20px 0; }
        .stat-val { display: block; font-weight: 800; font-size: 18px; }
        .stat-lbl { font-size: 12px; color: #888; }

        /* SHORTS */
        #shortsPage { height: calc(100vh - 65px); scroll-snap-type: y mandatory; overflow-y: auto; background: #000; }
        .short-frame { height: calc(100vh - 65px); width: 100vw; scroll-snap-align: start; position: relative; }
        .short-frame video { width: 100%; height: 100%; object-fit: cover; }
        .short-side { position: absolute; right: 15px; bottom: 120px; display: flex; flex-direction: column; gap: 25px; align-items: center; z-index: 10; }
        .side-btn { background: none; border: none; color: white; display: flex; flex-direction: column; gap: 5px; font-size: 13px; text-shadow: 0 2px 10px rgba(0,0,0,1); }

        /* CHAT */
        .chat-view { position: fixed; inset: 0; background: #000; z-index: 5000; display: none; flex-direction: column; }
        .chat-header { padding: 15px; border-bottom: 0.5px solid #222; display: flex; align-items: center; gap: 15px; background: rgba(0,0,0,0.9); }
        .messages-area { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 12px; }
        .msg-bubble { padding: 12px 16px; border-radius: 22px; max-width: 75%; font-size: 15px; line-height: 1.4; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .msg-me { background: linear-gradient(45deg, var(--blue), #00d4ff); align-self: flex-end; border-bottom-right-radius: 4px; }
        .msg-them { background: #262626; align-self: flex-start; border-bottom-left-radius: 4px; }
        .user-item { display: flex; align-items: center; gap: 15px; padding: 15px 20px; border-bottom: 0.5px solid #111; cursor: pointer; }
        .unread-badge { background: var(--blue); color: white; border-radius: 50%; width: 20px; height: 20px; font-size: 11px; display: flex; align-items: center; justify-content: center; }

        /* NAV */
        nav { position: fixed; bottom: 0; width: 100%; height: 65px; background: rgba(0,0,0,0.98); border-top: 0.5px solid #222; display: flex; justify-content: space-around; align-items: center; z-index: 2000; }
        .nav-link { color: #888; text-decoration: none; font-size: 22px; transition: 0.3s; }
        .nav-link.active { color: #fff; transform: translateY(-3px); }

        /* MODALES */
        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); z-index: 9000; align-items: center; justify-content: center; padding: 20px; }
        .modal-box { background: #1c1c1c; width: 100%; max-width: 400px; padding: 25px; border-radius: 30px; border: 1px solid #333; position: relative; }
        .close-modal { position: absolute; top: 20px; right: 20px; color: #888; font-size: 20px; cursor: pointer; }
        .user-select-item { display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 15px; cursor: pointer; transition: 0.2s; }
        .user-select-item:hover { background: #333; }
        .del-btn-mini { color: #ff3b30; font-size: 12px; background: none; border: none; font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>

    <div id="authOverlay">
        <div class="auth-card">
            <h1 class="logo" style="font-size: 35px; margin-bottom: 0;">Nexus</h1>
            <p id="authT" style="color:#666; font-size: 14px; margin-top: 5px;">Tu mundo, tus reglas.</p>
            <div id="regOnly" style="display:none; margin-top: 20px;">
                <input type="text" id="regName" class="auth-input" placeholder="Nombre de usuario">
                <input type="file" id="regFile" class="auth-input" accept="image/*">
            </div>
            <input type="email" id="authEmail" class="auth-input" placeholder="Correo" style="margin-top:20px">
            <input type="password" id="authPass" class="auth-input" placeholder="Contrase√±a">
            <button class="auth-btn" onclick="handleAuth()">CONTINUAR</button>
            <p onclick="toggleA()" style="margin-top:25px; color:var(--blue); cursor:pointer; font-weight: 600;" id="authL">¬øNuevo aqu√≠? Crea una cuenta</p>
        </div>
    </div>

    <div id="storyViewer">
        <div class="story-progress" id="sProgBar"></div>
        <div class="story-ui">
            <div id="sUAvatar" class="avatar-v" style="width:32px; height:32px; font-size:14px"></div>
            <b id="sUName" style="flex:1">Usuario</b>
            <i class="fas fa-trash" id="sUDel" style="color:#ff3b30; display:none; cursor:pointer"></i>
            <i class="fas fa-times" onclick="closeStory()" style="font-size:22px; cursor:pointer"></i>
        </div>
        <div class="story-content">
            <img id="sUImg" src="">
        </div>
    </div>

    <header class="app-header" id="hMain">
        <div class="top-nav">
            <div style="display:flex;align-items:center;gap:12px">
                <div class="logo">Nexus</div>
                <div class="search-wrap">
                    <input id="globalSearch" class="auth-input" placeholder="Buscar usuarios o videos...">
                </div>
            </div>
            <div id="myAvatar" class="avatar-v" style="width:34px; height:34px" onclick="changePage('profilePage', null)"></div>
        </div>
        <div class="stories-bar" id="storyBar">
            <div class="story-item" onclick="openModal('storyUpModal')" style="text-align:center; font-size:11px">
                <div class="story-ring" style="background:#222"><div class="story-pfp" style="color:var(--blue)">+</div></div>
                <span style="color:#888">Tu historia</span>
            </div>
        </div>
    </header>

    <div id="searchResults"></div>

    <div id="homePage" class="page active-page"></div>
    <div id="shortsPage" class="page"></div>
    <div id="inboxPage" class="page"><h3 style="padding:20px 20px 0">Mensajes</h3><div id="chatList"></div></div>
    
    <div id="profilePage" class="page">
        <div style="text-align:center; padding:50px 20px 20px">
            <div id="pBigAvatar" class="avatar-v" style="width:100px; height:100px; margin:0 auto; font-size:40px; border:3px solid var(--border)"></div>
            <h2 id="pNameDisp" style="margin:15px 0 5px; font-weight:800"></h2>
            
            <div class="profile-stats">
                <div class="stat-item"><span class="stat-val" id="statFollowers">0</span><span class="stat-lbl">Seguidores</span></div>
                <div class="stat-item"><span class="stat-val" id="statFollowing">0</span><span class="stat-lbl">Siguiendo</span></div>
                <div class="stat-item"><span class="stat-val" id="statLikes">0</span><span class="stat-lbl">Me gusta</span></div>
            </div>

            <p id="pEmailDisp" style="color:#555; margin-bottom:25px; font-size:14px"></p>
            <button onclick="logout()" style="background:#ff3b30; color:white; border:none; padding:10px 35px; border-radius:15px; font-weight:bold">Cerrar Sesi√≥n</button>
        </div>
    </div>

    <div id="chatView" class="chat-view">
        <div class="chat-header">
            <i class="fas fa-arrow-left" onclick="closeChat()" style="font-size:20px"></i>
            <div id="chatContactAvatar" class="avatar-v" style="width:35px; height:35px"></div>
            <b id="chatContactName">Usuario</b>
        </div>
        <div class="messages-area" id="msgArea"></div>
        <div class="chat-input-area" style="padding:15px; display:flex; gap:10px; background:#000; align-items:center">
            <i class="fas fa-image" onclick="sendMediaMsg('image')" style="color:#888; font-size:22px"></i>
            <input type="text" id="msgInput" class="auth-input" style="margin:0; flex:1" placeholder="Escribe...">
            <button class="act-btn" style="color:var(--blue); font-size:20px" onclick="sendTextMsg()"><i class="fas fa-paper-plane"></i></button>
        </div>
    </div>

    <div id="shareModal" class="modal"><div class="modal-box">
        <h3>Enviar a...</h3>
        <div id="shareListUsers" style="max-height:300px; overflow-y:auto; margin-bottom:20px"></div>
        <button class="auth-btn" style="background:#222" onclick="closeModal('shareModal')">Cancelar</button>
    </div></div>

    <div id="commentModal" class="modal">
        <div class="modal-box">
            <i class="fas fa-times close-modal" onclick="closeModal('commentModal')"></i>
            <h3 style="margin-top: 0;">Comentarios</h3>
            <div id="commList" style="max-height:300px; overflow-y:auto; margin-bottom:15px; font-size:14px"></div>
            <div style="display:flex; gap:10px">
                <input type="text" id="commInput" class="auth-input" placeholder="Escribe un comentario..." style="margin:0">
                <button class="auth-btn" style="margin:0; width:60px" onclick="postComment()"><i class="fas fa-check"></i></button>
            </div>
        </div>
    </div>

    <div id="uploadModal" class="modal"><div class="modal-box">
        <h3>Nueva Publicaci√≥n</h3>
        <select id="vT" class="auth-input"><option value="video">üéûÔ∏è Video (YouTube)</option><option value="short">‚ö° Short (TikTok)</option></select>
        <input type="text" id="vTitle" class="auth-input" placeholder="T√≠tulo">
        <input type="file" id="vFile" class="auth-input" accept="video/*">
        <button class="auth-btn" onclick="upVideo()">PUBLICAR</button>
        <button class="auth-btn" style="background:none" onclick="closeModal('uploadModal')">Cerrar</button>
    </div></div>

    <div id="storyUpModal" class="modal"><div class="modal-box">
        <h3>Tu Historia</h3>
        <input type="file" id="sFile" class="auth-input" accept="image/*">
        <button class="auth-btn" style="background:var(--accent)" onclick="upStory()">SUBIR AHORA</button>
        <button class="auth-btn" style="background:none" onclick="closeModal('storyUpModal')">Cerrar</button>
    </div></div>

    <nav>
        <a href="#" class="nav-link active" onclick="changePage('homePage', this)"><i class="fas fa-home"></i></a>
        <a href="#" class="nav-link" onclick="changePage('shortsPage', this)"><i class="fas fa-bolt"></i></a>
        <a href="#" class="nav-link" onclick="openModal('uploadModal')"><i class="fas fa-plus-circle" style="font-size:30px; color:white"></i></a>
        <a href="#" class="nav-link" onclick="changePage('inboxPage', this)"><i class="fas fa-comment"></i></a>
        <a href="#" class="nav-link" onclick="changePage('profilePage', this)"><i class="fas fa-user"></i></a>
    </nav>

    <!-- ========== MAIN APP SCRIPT (tu c√≥digo, con adaptaciones Supabase) ========== -->
    <script>
        let db;
        let isReg = false;
        // local saved user (from previous login)
        let user = JSON.parse(localStorage.getItem('nexus_v9_user'));
        let activeVidId = null, activeChatEmail = null;
        let storyTimer = null;

        async function hashPass(password) {
            const msgUint8 = new TextEncoder().encode(password);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        const request = indexedDB.open("NexusInfinity_V9", 2);
        request.onupgradeneeded = e => {
            db = e.target.result;
            if (!db.objectStoreNames.contains("users")) db.createObjectStore("users", { keyPath: "email" });
            if (!db.objectStoreNames.contains("videos")) db.createObjectStore("videos", { keyPath: "id", autoIncrement: true });
            if (!db.objectStoreNames.contains("stories")) db.createObjectStore("stories", { keyPath: "id", autoIncrement: true });
            if (!db.objectStoreNames.contains("chats")) db.createObjectStore("chats", { keyPath: "id", autoIncrement: true });
        };
        request.onsuccess = e => { 
            db = e.target.result; 
            if(user) { 
                document.getElementById('authOverlay').style.display='none'; 
                autoCleanup();
                init(); 
            }
        };

        function toggleA() {
            isReg = !isReg;
            document.getElementById('authT').innerText = isReg ? "Crea tu cuenta de Nexus" : "Tu mundo, tus reglas.";
            document.getElementById('regOnly').style.display = isReg ? "block" : "none";
        }

        // EMAIL validation helper
        function validEmailFormat(e) {
            return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e);
        }

        async function handleAuth() {
            const e = document.getElementById('authEmail').value.trim().toLowerCase();
            const p = document.getElementById('authPass').value;
            if(!e || !p) return alert("Completa los campos");
            if(!validEmailFormat(e)) return alert("Introduce un correo v√°lido.");
            const hashed = await hashPass(p);

            if(isReg) {
                // require gmail for registering (you can change this)
                if(!e.endsWith('@gmail.com')) return alert("Reg√≠strate con una cuenta Gmail (ej: usuario@gmail.com).");
                if(p.length < 8) return alert("La contrase√±a debe tener al menos 8 caracteres.");
                const n = document.getElementById('regName').value.trim(), f = document.getElementById('regFile').files[0];
                if(!n) return alert("Nombre requerido");
                db.transaction("users").objectStore("users").get(e).onsuccess = async (ev) => {
                    if(ev.target.result) return alert("El correo ya existe");
                    const pfp = f ? await toB64(f) : null;
                    const u = { email:e, pass:hashed, name:n, pfp:pfp, color:randCol(), followers: [], following: [] };
                    db.transaction("users","readwrite").objectStore("users").add(u).onsuccess = () => {
                        login(u);
                    };
                };
            } else {
                db.transaction("users").objectStore("users").get(e).onsuccess = res => {
                    const u = res.target.result;
                    if(u && u.pass === hashed) login(u); else alert("Datos incorrectos");
                };
            }
        }

        function login(u) { localStorage.setItem('nexus_v9_user', JSON.stringify(u)); user = u; location.reload(); }
        function logout() { localStorage.removeItem('nexus_v9_user'); localStorage.clear(); location.reload(); }

        function init() {
            setAvatar(document.getElementById('myAvatar'), user);
            setAvatar(document.getElementById('pBigAvatar'), user);
            document.getElementById('pNameDisp').innerText = user.name;
            document.getElementById('pEmailDisp').innerText = user.email;
            updateProfileStats();
            renderHome();
            renderStories();
            renderInbox();
        }

        function updateProfileStats() {
            db.transaction("users").objectStore("users").get(user.email).onsuccess = e => {
                const u = e.target.result;
                if(!u) return;
                document.getElementById('statFollowers').innerText = u.followers ? u.followers.length : 0;
                document.getElementById('statFollowing').innerText = u.following ? u.following.length : 0;
            };
            db.transaction("videos").objectStore("videos").getAll().onsuccess = e => {
                const myVids = e.target.result.filter(v => v.email === user.email);
                const totalLikes = myVids.reduce((acc, v) => acc + (v.likedBy ? v.likedBy.length : 0), 0);
                document.getElementById('statLikes').innerText = totalLikes;
            };
        }

        function setAvatar(el, u) {
            if(!u) return;
            if(u.pfp) el.innerHTML = `<img src="${u.pfp}" style="width:100%; height:100%; object-fit:cover">`;
            else { el.innerText = u.name ? u.name[0].toUpperCase() : '?'; el.style.background = u.color || '#333'; }
        }

        // --- LIKES REALES ---
        function toggleLike(id, btn) {
            const tx = db.transaction("videos", "readwrite"), st = tx.objectStore("videos");
            st.get(id).onsuccess = e => {
                const v = e.target.result;
                if(!v.likedBy) v.likedBy = [];
                const idx = v.likedBy.indexOf(user.email);
                if(idx > -1) v.likedBy.splice(idx, 1);
                else v.likedBy.push(user.email);
                st.put(v);
                tx.oncomplete = () => {
                    btn.classList.toggle('active-l');
                    if(btn.querySelector('span')) btn.querySelector('span').innerText = v.likedBy.length;
                    updateProfileStats();
                };
            };
        }

        // --- SEGUIDORES REALES ---
        function toggleSub(targetEmail) {
            const tx = db.transaction("users", "readwrite"), st = tx.objectStore("users");
            st.get(user.email).onsuccess = e1 => {
                const me = e1.target.result;
                st.get(targetEmail).onsuccess = e2 => {
                    const target = e2.target.result;
                    if(!me.following) me.following = [];
                    if(!target.followers) target.followers = [];

                    const idx = me.following.indexOf(targetEmail);
                    if(idx > -1) {
                        me.following.splice(idx, 1);
                        const fi = target.followers.indexOf(user.email);
                        if(fi > -1) target.followers.splice(fi, 1);
                    } else {
                        me.following.push(targetEmail);
                        target.followers.push(user.email);
                    }
                    st.put(me);
                    st.put(target);
                    tx.oncomplete = () => {
                        user = me;
                        localStorage.setItem('nexus_v9_user', JSON.stringify(me));
                        renderHome();
                        updateProfileStats();
                    };
                };
            };
        }

        // --- CHAT REALISTA ---
        function openChat(email, name, pfp, color) {
            activeChatEmail = email;
            document.getElementById('chatView').style.display = 'flex';
            document.getElementById('chatContactName').innerText = name;
            setAvatar(document.getElementById('chatContactAvatar'), { pfp, name, color });
            loadMessages();
        }

        function closeChat() { document.getElementById('chatView').style.display='none'; activeChatEmail=null; renderInbox(); }

        function sendTextMsg() {
            const input = document.getElementById('msgInput');
            const val = input.value.trim();
            if(!val) return;
            const msg = { from: user.email, to: activeChatEmail, type: 'text', content: val, timestamp: Date.now(), seen: false };
            db.transaction("chats","readwrite").objectStore("chats").add(msg).onsuccess = () => {
                input.value = "";
                loadMessages();
            };
        }

        function sendMediaMsg(type) {
            const picker = document.createElement('input');
            picker.type = 'file';
            picker.accept = type === 'image' ? 'image/*' : 'video/*';
            picker.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const b = await toB64(file); // small images -> base64 ok
                    const msg = { from: user.email, to: activeChatEmail, type, content: b, timestamp: Date.now(), seen: false };
                    db.transaction("chats","readwrite").objectStore("chats").add(msg).onsuccess = () => loadMessages();
                }
            };
            picker.click();
        }

        function loadMessages() {
            db.transaction("chats").objectStore("chats").getAll().onsuccess = e => {
                const conversation = e.target.result.filter(m => 
                    (m.from === user.email && m.to === activeChatEmail) || (m.from === activeChatEmail && m.to === user.email)
                ).sort((a,b) => a.timestamp - b.timestamp);

                const area = document.getElementById('msgArea');
                area.innerHTML = conversation.map(m => {
                    const isMe = m.from === user.email;
                    if(!isMe && !m.seen) markAsSeen(m.id);
                    let body = m.type === 'text' ? `<span>${escapeHtml(m.content)}</span>` : 
                               (m.type === 'image' ? `<img src="${m.content}" style="max-width:200px; border-radius:10px">` : 
                               `<video src="${m.content}" controls style="max-width:200px; border-radius:10px"></video>`);

                    return `<div class="msg-bubble ${isMe ? 'msg-me' : 'msg-them'}">
                                ${body}
                                <div style="font-size:9px; opacity:0.6; text-align:right; margin-top:4px">
                                    ${new Date(m.timestamp).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})} 
                                    ${isMe ? (m.seen ? '<i class="fas fa-check-double" style="color:#fff"></i>' : '<i class="fas fa-check"></i>') : ''}
                                </div>
                            </div>`;
                }).join('');
                area.scrollTop = area.scrollHeight;
            };
        }

        function markAsSeen(id) {
            const tx = db.transaction("chats","readwrite");
            const st = tx.objectStore("chats");
            st.get(id).onsuccess = e => { 
                const m = e.target.result; 
                if(m) { m.seen=true; st.put(m); } 
            };
        }

        function renderInbox() {
            db.transaction("users").objectStore("users").getAll().onsuccess = e => {
                const users = e.target.result.filter(u => u.email !== user.email);
                db.transaction("chats").objectStore("chats").getAll().onsuccess = ec => {
                    const allMsgs = ec.target.result;
                    document.getElementById('chatList').innerHTML = users.map(u => {
                        const uMsgs = allMsgs.filter(m => m.from === u.email || m.to === u.email);
                        const last = uMsgs.sort((a,b) => b.timestamp - a.timestamp)[0];
                        const unread = uMsgs.filter(m => m.from === u.email && m.to === user.email && !m.seen).length;
                        return `<div class="user-item" onclick="openChat('${u.email}','${u.name}','${u.pfp}','${u.color}')">
                            <div class="avatar-v" style="background:${u.color}; width:50px; height:50px">${u.pfp?`<img src="${u.pfp}" style="width:100%;height:100%;object-fit:cover">`:u.name[0]}</div>
                            <div style="flex:1"><b>${u.name}</b><br><small style="color:#666">${last ? (last.type==='text'?escapeHtml(last.content):'Multimedia') : 'Sin mensajes'}</small></div>
                            ${unread ? `<div class="unread-badge">${unread}</div>`:''}
                        </div>`;
                    }).join('');
                };
            };
        }

        // --- VIDEOS, STORIES & UTILS ---
        function renderHome() {
            db.transaction("videos").objectStore("videos").getAll().onsuccess = e => {
                const list = e.target.result.filter(v => v.type === 'video').reverse();
                const container = document.getElementById('homePage');
                container.innerHTML = '';
                list.forEach(v => {
                    let src = '';
                    if(v.blob && typeof v.blob === 'string') src = v.blob;               // public URL or base64
                    else if(v.file) src = URL.createObjectURL(v.file); // File stored in IDB
                    else if(v.fileBlob) src = URL.createObjectURL(v.fileBlob);
                    // Build card, include data-vid attribute for search jump
                    container.innerHTML += `
                    <div class="video-card" data-vid="${v.id}">
                        <video src="${src}" controls preload="metadata"></video>
                        <div class="v-body">
                            <div class="avatar-v" style="background:${v.color}">${v.pfp?`<img src="${v.pfp}" style="width:100%;height:100%;object-fit:cover">`: (v.author?v.author[0]:'?')}</div>
                            <div style="flex:1"><b>${escapeHtml(v.title)}</b><br><small style="color:#666">${escapeHtml(v.author)}</small></div>
                            ${v.email === user.email ? `<button class="del-btn-mini" onclick="deleteContent('videos', ${v.id})">Borrar</button>` : `<button onclick="toggleSub('${v.email}')" style="background:${(user.following||[]).includes(v.email)?'#222':'var(--blue)'}; color:white; border:none; padding:6px 15px; border-radius:10px; font-weight:600; font-size:12px">${(user.following||[]).includes(v.email)?'Siguiendo':'Seguir'}</button>`}
                        </div>
                        <div class="v-actions">
                            <div class="act-group">
                                <button class="act-btn ${(v.likedBy||[]).includes(user.email)?'active-l':''}" onclick="toggleLike(${v.id}, this)"><i class="fas fa-heart"></i></button>
                                <button class="act-btn" onclick="openComms(${v.id})"><i class="fas fa-comment"></i></button>
                                <button class="act-btn" onclick="openSharePicker(${v.id})"><i class="fas fa-paper-plane"></i></button>
                            </div>
                        </div>
                    </div>`;
                });
            };
        }

        async function upVideo() {
            const f = document.getElementById('vFile').files[0], t = document.getElementById('vTitle').value.trim(), tp = document.getElementById('vT').value;
            if(!f) return alert("Selecciona un archivo");

            // Preferir subir a Supabase (si el bridge est√° disponible)
            const bridge = window.nexus_bridge || null;
            try {
                if(bridge && typeof bridge.uploadFileToStorage === 'function'){
                    // upload via bridge helper (returns { publicUrl, path })
                    const res = await bridge.uploadFileToStorage(bridge.config?.VIDEOS_BUCKET || 'videos', f);
                    const publicUrl = (res && res.publicUrl) ? res.publicUrl : res;
                    const remote_path = res && res.path ? res.path : null;

                    const vid = { 
                        title: t || f.name, 
                        blob: publicUrl, 
                        remote_url: publicUrl, 
                        remote_path: remote_path, 
                        type: tp, 
                        author: user.name, 
                        email: user.email, 
                        pfp: user.pfp, 
                        color: user.color, 
                        likedBy: [], 
                        comms:[], 
                        timestamp: Date.now(),
                        synced: true
                    };
                    db.transaction("videos","readwrite").objectStore("videos").add(vid).onsuccess = () => {
                        // create remote record as well (bridge will do if available)
                        if(typeof bridge.createRemoteVideoRecord === 'function'){
                            bridge.createRemoteVideoRecord({
                                title: vid.title, url: publicUrl, remote_path: remote_path, type: vid.type, author: vid.author, email: vid.email, pfp: vid.pfp, color: vid.color, timestamp: vid.timestamp
                            });
                        }
                        closeModal('uploadModal');
                        setTimeout(()=>{ if(typeof renderHome==='function') renderHome(); },400);
                    };
                    return;
                }
            } catch(err){
                console.warn("Subida via bridge fall√≥, fallback local:", err);
            }

            // fallback (sin Supabase): store File in IDB or base64
            try {
                const vid = { title:t, blob:null, file: f, type:tp, author:user.name, email:user.email, pfp:user.pfp, color:user.color, likedBy: [], comms:[], timestamp: Date.now() };
                db.transaction("videos","readwrite").objectStore("videos").add(vid).onsuccess = () => location.reload();
            } catch(err) {
                // fallback: convert small files to base64
                const b = await toB64(f);
                const vid = { title:t, blob:b, type:tp, author:user.name, email:user.email, pfp:user.pfp, color:user.color, likedBy: [], comms:[], timestamp: Date.now() };
                db.transaction("videos","readwrite").objectStore("videos").add(vid).onsuccess = () => location.reload();
            }
        }

        function openSharePicker(vidId) {
            activeVidId = vidId;
            db.transaction("users").objectStore("users").getAll().onsuccess = e => {
                const allUsers = e.target.result.filter(u => u.email !== user.email);
                document.getElementById('shareListUsers').innerHTML = allUsers.map(u => `
                    <div class="user-select-item" onclick="confirmShare('${u.email}', '${escapeHtml(u.name)}')">
                        <div class="avatar-v" style="background:${u.color}; width:40px; height:40px">${u.pfp?`<img src="${u.pfp}" style="width:100%;height:100%;object-fit:cover">`:u.name[0]}</div>
                        <b>${escapeHtml(u.name)}</b>
                    </div>`).join('');
                openModal('shareModal');
            };
        }

        function confirmShare(email, name) {
            db.transaction("videos").objectStore("videos").get(activeVidId).onsuccess = e => {
                const v = e.target.result;
                // prefer to share stored blob/file as base64 for chat (small) ‚Äî for big files you'd implement cloud share link
                let content = v.blob || null;
                if(!content && v.file) {
                    // small optimization: don't convert large files to base64; createObjectURL and send not persistent
                    content = URL.createObjectURL(v.file);
                }
                const msg = { from: user.email, to: email, type: 'video', content: content || '', timestamp: Date.now(), seen:false };
                db.transaction("chats","readwrite").objectStore("chats").add(msg).onsuccess = () => {
                    alert("Enviado a " + name);
                    closeModal('shareModal');
                };
            };
        }

        function openComms(id) {
            activeVidId = id;
            db.transaction("videos").objectStore("videos").get(id).onsuccess = e => {
                const v = e.target.result;
                document.getElementById('commList').innerHTML = (v.comms||[]).map(c => `
                    <div style="margin-bottom:15px; display:flex; gap:10px; align-items:start">
                        <div class="avatar-v" style="width:25px; height:25px; font-size:10px; background:#444">${escapeHtml((c.u||'')[0]||'?')}</div>
                        <div><b style="font-size:12px">${escapeHtml(c.u)}</b><br>${escapeHtml(c.t)}</div>
                    </div>`).join('') || "<p style='color:#555; text-align:center'>No hay comentarios a√∫n.</p>";
                openModal('commentModal');
            };
        }

        function postComment() {
            const t = document.getElementById('commInput').value; if(!t) return;
            const tx = db.transaction("videos", "readwrite"), st = tx.objectStore("videos");
            st.get(activeVidId).onsuccess = e => {
                const v = e.target.result; if(!v.comms) v.comms = [];
                v.comms.push({u:user.name, t:t, email: user.email});
                st.put(v); tx.oncomplete = () => { document.getElementById('commInput').value=""; openComms(activeVidId); };
            };
        }

        function renderStories() {
            const now = Date.now();
            db.transaction("stories").objectStore("stories").getAll().onsuccess = e => {
                const sItems = e.target.result.filter(s => (now - s.created) < 24 * 60 * 60 * 1000);
                const container = document.getElementById('storyBar');
                container.innerHTML = `<div class="story-item" onclick="openModal('storyUpModal')" style="text-align:center; font-size:11px"><div class="story-ring" style="background:#222"><div class="story-pfp" style="color:var(--blue)">+</div></div><span style="color:#888">Tu historia</span></div>`;
                sItems.forEach(s => {
                    const d = document.createElement('div'); d.className='story-item';
                    d.innerHTML = `<div class="story-ring"><div class="story-pfp" style="background:${s.color}">${s.pfp?`<img src="${s.pfp}" style="width:100%;height:100%;object-fit:cover">`:s.author[0]}</div></div><span style="font-size:10px; color:#aaa; margin-top:5px; display:block; text-align:center">${escapeHtml(s.author)}</span>`;
                    d.onclick = () => viewStory(s);
                    container.appendChild(d);
                });
            };
        }

        function upStory() {
            const f = document.getElementById('sFile').files[0]; if(!f) return;
            const bridge = window.nexus_bridge || null;
            if(bridge && typeof bridge.uploadFileToStorage === 'function'){
                // upload directly via bridge
                bridge.uploadFileToStorage(bridge.config?.STORIES_BUCKET || 'stories', f).then(res=>{
                    const publicUrl = (res && res.publicUrl) ? res.publicUrl : res;
                    const remote_path = res && res.path ? res.path : null;
                    const story = { img: publicUrl, remote_path: remote_path, author: user.name, email: user.email, color:user.color, pfp:user.pfp, created: Date.now(), synced: true };
                    db.transaction("stories","readwrite").objectStore("stories").add(story).onsuccess = () => {
                        if(typeof bridge.createRemoteStoryRecord === 'function') bridge.createRemoteStoryRecord({ img: publicUrl, remote_path: remote_path, author: story.author, email: story.email, pfp: story.pfp, color: story.color, created: story.created });
                        setTimeout(()=>{ if(typeof renderStories==='function') renderStories(); },300);
                        closeModal('storyUpModal');
                    };
                }).catch(err=>{
                    console.error("Error subida story bridge:",err);
                    // fallback to dataURL
                    const r = new FileReader(); r.readAsDataURL(f);
                    r.onload = () => {
                        const s = { img:r.result, author:user.name, email:user.email, color:user.color, pfp:user.pfp, created: Date.now() };
                        db.transaction("stories","readwrite").objectStore("stories").add(s).onsuccess = () => location.reload();
                    };
                });
                return;
            }
            // fallback: store as dataURL
            const r = new FileReader(); r.readAsDataURL(f);
            r.onload = () => {
                const s = { img:r.result, author:user.name, email:user.email, color:user.color, pfp:user.pfp, created: Date.now() };
                db.transaction("stories","readwrite").objectStore("stories").add(s).onsuccess = () => location.reload();
            };
        }

        function viewStory(s) {
            const viewer = document.getElementById('storyViewer');
            document.getElementById('sUImg').src = s.img;
            document.getElementById('sUName').innerText = s.author;
            setAvatar(document.getElementById('sUAvatar'), s);
            viewer.style.display = 'flex';
            document.getElementById('sProgBar').innerHTML = '<div class="prog-bg"><div class="prog-fill" id="curFill"></div></div>';
            setTimeout(() => { document.getElementById('curFill').style.width = '100%'; }, 50);
            clearTimeout(storyTimer);
            storyTimer = setTimeout(closeStory, 5000);
        }

        function closeStory() { document.getElementById('storyViewer').style.display='none'; clearTimeout(storyTimer); }

        function changePage(id, el) {
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active-page'));
            document.getElementById(id).classList.add('active-page');
            document.querySelectorAll('.nav-link').forEach(n => n.classList.remove('active'));
            if(el) el.classList.add('active');
            if(id === 'inboxPage') renderInbox();
            if(id === 'shortsPage') renderShorts();
            if(id === 'homePage') renderHome();
        }

        function renderShorts() {
            db.transaction("videos").objectStore("videos").getAll().onsuccess = e => {
                const list = e.target.result
                    .filter(v => v.type === 'short')
                    .sort((a, b) => (b.likes || 0) - (a.likes || 0) || b.timestamp - a.timestamp);
                const container = document.getElementById('shortsPage');
                container.innerHTML = '';
                list.forEach(s => {
                    let src = s.blob || (s.file ? URL.createObjectURL(s.file) : '');
                    container.innerHTML += `
                        <div class="short-frame" data-vid="${s.id}">
                            <video src="${src}" loop playsinline onclick="this.paused?this.play():this.pause()"></video>
                            <div class="short-side">
                                <div class="avatar-v" style="background:${s.color}; border:2px solid white">${s.pfp?`<img src="${s.pfp}" style="width:100%;height:100%;object-fit:cover">`:s.author[0]}</div>
                                <button class="side-btn ${(s.likedBy||[]).includes(user.email)?'active-l':''}" onclick="toggleLike(${s.id}, this)"><i class="fas fa-heart fa-2x"></i><span>${s.likedBy? s.likedBy.length : (s.likes||0)}</span></button>
                                <button class="side-btn" onclick="openComms(${s.id})"><i class="fas fa-comment fa-2x"></i><span>${s.comms? s.comms.length:0}</span></button>
                                <button class="side-btn" onclick="openSharePicker(${s.id})"><i class="fas fa-share fa-2x"></i></button>
                                ${s.email === user.email ? `<button class="side-btn" onclick="deleteContent('videos', ${s.id})" style="color:#ff3b30"><i class="fas fa-trash fa-lg"></i></button>` : ''}
                            </div>
                            <div style="position:absolute; bottom:30px; left:20px; text-shadow:0 2px 10px #000; pointer-events:none">
                                <b>@${escapeHtml(s.author)}</b><p style="margin:5px 0">${escapeHtml(s.title)}</p>
                            </div>
                        </div>`;
                });
            };
        }

        // DELETE: ahora intenta borrar de Supabase (storage + tabla remota) si existe remote_path
        async function deleteContent(store, id) { 
            if(!confirm("¬øBorrar?")) return;
            try {
                const tx = db.transaction(store, "readwrite");
                const st = tx.objectStore(store);
                st.get(id).onsuccess = async (e) => {
                    const rec = e.target.result;
                    if(!rec) return;
                    const bridge = window.nexus_bridge || null;
                    if(bridge && bridge.supabase){
                        try {
                            // si tenemos remote_path, borrar del storage
                            if(rec.remote_path){
                                await bridge.supabase.storage.from(bridge.config?.VIDEOS_BUCKET || 'videos').remove([rec.remote_path]);
                            } else if(rec.remote_url){
                                // intentar derivar path (no siempre posible); si tienes saved remote_path prefer usarlo
                                // fallback: we won't try to derive automatically
                            }
                            // borrar fila en tabla remota por remote_path o por url
                            if(rec.remote_path){
                                await bridge.supabase.from('videos').delete().eq('remote_path', rec.remote_path);
                            } else if(rec.remote_url){
                                await bridge.supabase.from('videos').delete().eq('url', rec.remote_url);
                            } else {
                                // si no hay datos remotos, no hay nada que borrar en Supabase
                            }
                        } catch(err){
                            console.warn("Error borrando en Supabase (continuando con borrado local):", err);
                        }
                    }
                    // borrar local
                    st.delete(id).onsuccess = () => {
                        if(typeof renderHome === 'function') setTimeout(()=>renderHome(),250);
                    };
                };
            } catch(err){
                console.error("deleteContent error:",err);
            }
        }

        function toB64(f) { return new Promise(r => { const rd = new FileReader(); rd.onload = () => r(rd.result); rd.readAsDataURL(f); }); }
        function randCol() { return '#' + Math.floor(Math.random()*16777215).toString(16); }
        function openModal(id) { document.getElementById(id).style.display = 'flex'; }
        function closeModal(id) { document.getElementById(id).style.display = 'none'; }
        function autoCleanup() { /* La l√≥gica de historias 24h ya est√° aplicada en renderStories */ }

        // small helper to escape HTML in strings
        function escapeHtml(str) {
            if(!str && str !== 0) return '';
            return String(str).replace(/[&<>"'`=\/]/g, function (s) {
                return ({
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;',
                    '/': '&#x2F;',
                    '`': '&#x60;',
                    '=': '&#x3D;'
                })[s];
            });
        }

        /* ========== SEARCH - simple client search that queries IDB and shows results ========== */
        (function(){
            const input = document.getElementById('globalSearch');
            const resultsBox = document.getElementById('searchResults');
            let timer=null;
            input.addEventListener('input', (e) => {
                clearTimeout(timer);
                timer = setTimeout(()=>performSearch(e.target.value.trim()), 220);
            });

            async function performSearch(q){
                if(!q){ resultsBox.style.display='none'; resultsBox.innerHTML=''; return; }
                // search users and videos
                try {
                    const users = await new Promise(res=> db.transaction('users').objectStore('users').getAll().onsuccess = ev => res(ev.target.result || []));
                    const videos = await new Promise(res=> db.transaction('videos').objectStore('videos').getAll().onsuccess = ev => res(ev.target.result || []));
                    const uq = q.toLowerCase();
                    const userMatches = users.filter(u => (u.name && u.name.toLowerCase().includes(uq)) || (u.email && u.email.toLowerCase().includes(uq))).slice(0,10);
                    const videoMatches = videos.filter(v => (v.title && v.title.toLowerCase().includes(uq)) || (v.author && v.author.toLowerCase().includes(uq))).slice(0,15);

                    let html = '';
                    if(userMatches.length){
                        html += `<div style="padding:6px 10px; color:#bbb; font-size:12px">Usuarios</div>`;
                        userMatches.forEach(u=>{
                            html += `<div class="sr-item" data-type="user" data-email="${u.email}">
                                <div class="avatar-v" style="width:40px;height:40px;background:${u.color}">${u.pfp?`<img src="${u.pfp}" style="width:100%;height:100%;object-fit:cover">`: (u.name?u.name[0]:'?')}</div>
                                <div style="flex:1"><b>${escapeHtml(u.name)}</b><br><small style="color:#888">${escapeHtml(u.email)}</small></div>
                            </div>`;
                        });
                    }
                    if(videoMatches.length){
                        html += `<div style="padding:6px 10px; color:#bbb; font-size:12px">Videos</div>`;
                        videoMatches.forEach(v=>{
                            html += `<div class="sr-item" data-type="video" data-vid="${v.id}">
                                <div style="width:44px;height:44px;border-radius:6px;background:#111;display:flex;align-items:center;justify-content:center">${v.title?escapeHtml(v.title.substring(0,2)):'V'}</div>
                                <div style="flex:1"><b>${escapeHtml(v.title)}</b><br><small style="color:#888">${escapeHtml(v.author||'')}</small></div>
                            </div>`;
                        });
                    }
                    if(!html) html = `<div style="padding:12px; color:#777; text-align:center">No se encontraron resultados</div>`;
                    resultsBox.innerHTML = html;
                    resultsBox.style.display = 'block';

                    // delegate clicks
                    resultsBox.querySelectorAll('.sr-item').forEach(it=>{
                        it.onclick = () => {
                            const ty = it.getAttribute('data-type');
                            if(ty === 'user'){
                                const email = it.getAttribute('data-email');
                                // open profile (find user and navigate to profilePage)
                                db.transaction('users').objectStore('users').get(email).onsuccess = ev => {
                                    const u = ev.target.result;
                                    if(u){
                                        // create a temporary profile view: set fields and go to profilePage
                                        setAvatar(document.getElementById('pBigAvatar'), u);
                                        document.getElementById('pNameDisp').innerText = u.name;
                                        document.getElementById('pEmailDisp').innerText = u.email;
                                        // show profile page
                                        changePage('profilePage');
                                        resultsBox.style.display='none';
                                    }
                                };
                            } else {
                                const vid = it.getAttribute('data-vid');
                                // go to homePage and scroll to video card
                                changePage('homePage');
                                setTimeout(()=>{
                                    const el = document.querySelector(`[data-vid="${vid}"]`);
                                    if(el){ el.scrollIntoView({behavior:'smooth', block:'center'}); el.style.boxShadow='0 6px 30px rgba(0,0,0,0.6)'; setTimeout(()=>el.style.boxShadow='none',1800); }
                                    resultsBox.style.display='none';
                                },250);
                            }
                        };
                    });

                } catch(err){
                    console.error("Search error",err);
                    resultsBox.style.display='none';
                }
            }

            // hide on outside click
            document.addEventListener('click', (e) => {
                if(!resultsBox.contains(e.target) && e.target !== input) resultsBox.style.display='none';
            });
        })();

    </script>

    <!-- ========== SUPABASE CDN (necesario para el bridge) ========== -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.33.1/dist/supabase.min.js"></script>

    <!-- ========== NEXUS BRIDGE INLINE (subidas a Storage, sync chats, presence) ========== -->
    <script>
    /* gateway bridge (inline). If you already loaded a bridge separately, remove this block to avoid duplicate declarations. */
    if(!window._nexus_bridge_loaded){
      window._nexus_bridge_loaded = true;

      (function () {
        // CONFIG - reemplaza si quieres otros valores
        const SUPABASE_URL = "https://dmlwrwovwzvcfeoxyxtb.supabase.co";
        const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtbHdyd292d3p2Y2Zlb3h5eHRiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc2NjMzNTgsImV4cCI6MjA4MzIzOTM1OH0.hukw5FC7S3gV-4PFh1Bskj9dm_7qsNTrrKVJqh2ORMQ";
        const VIDEOS_BUCKET = "videos";
        const STORIES_BUCKET = "stories";
        const POLL_INTERVAL_MS = 2000;

        // use existing window.user/db
        window.user = window.user || JSON.parse(localStorage.getItem('nexus_v9_user') || 'null');
        const user = window.user || null;

        if (!window.supabase || typeof window.supabase.createClient !== 'function') {
          console.warn("Supabase JS no encontrado o carga lenta. El bridge esperar√° a que est√© disponible.");
        }

        const supabase = window.supabase ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY) : null;

        function waitForDB(timeout = 15000) {
          return new Promise((resolve, reject) => {
            const start = Date.now();
            (function check() {
              if (window.db) return resolve(window.db);
              if (Date.now() - start > timeout) return reject(new Error("Timeout esperando IndexedDB (window.db)"));
              setTimeout(check, 200);
            })();
          });
        }

        function dataURLtoBlob(dataurl) {
          const arr = dataurl.split(',');
          const mime = arr[0].match(/:(.*?);/)[1];
          const bstr = atob(arr[1]);
          let n = bstr.length;
          const u8arr = new Uint8Array(n);
          while (n--) u8arr[n] = bstr.charCodeAt(n);
          return new Blob([u8arr], { type: mime });
        }

        // MOD: devuelve { publicUrl, path } para poder borrar luego por path
        async function uploadFileToStorage(bucket, file, path) {
          if(!supabase) throw new Error("Supabase no inicializado");
          try {
            const filePath = path || `${user ? user.email.replace(/[@.]/g, '_') : 'anon'}_${Date.now()}_${file.name}`;
            const { error } = await supabase.storage.from(bucket).upload(filePath, file, { upsert: false });
            if (error) throw error;
            const { data: pub } = supabase.storage.from(bucket).getPublicUrl(filePath);
            return { publicUrl: pub.publicUrl, path: filePath };
          } catch (err) {
            console.error("uploadFileToStorage error:", err);
            throw err;
          }
        }

        async function createRemoteVideoRecord(meta) {
          if(!supabase) return;
          try { const { error } = await supabase.from('videos').insert([meta]); if (error) console.error("createRemoteVideoRecord:", error); } catch (err) { console.error(err); }
        }
        async function createRemoteStoryRecord(meta) {
          if(!supabase) return;
          try { const { error } = await supabase.from('stories').insert([meta]); if (error) console.error("createRemoteStoryRecord:", error); } catch (err) { console.error(err); }
        }

        async function syncLocalVideos(db) {
          try {
            const tx = db.transaction("videos", "readwrite");
            const store = tx.objectStore("videos");
            store.getAll().onsuccess = async (e) => {
              const list = e.target.result || [];
              for (const v of list) {
                if (v.blob && typeof v.blob === 'string' && v.blob.startsWith('data:') && !v.synced) {
                  try {
                    const blob = dataURLtoBlob(v.blob);
                    const file = new File([blob], (v.title || 'video') + '.webm', { type: blob.type || 'video/webm' });
                    const { publicUrl, path } = await uploadFileToStorage(VIDEOS_BUCKET, file);
                    v.blob = publicUrl;
                    v.remote_url = publicUrl;
                    v.remote_path = path;
                    v.synced = true;
                    store.put(v);
                    createRemoteVideoRecord({
                      title: v.title || 'Untitled', url: publicUrl, remote_path: path, type: v.type || 'video',
                      author: v.author || (user && user.name) || null, email: v.email || (user && user.email) || null,
                      pfp: v.pfp || (user && user.pfp) || null, color: v.color || (user && user.color) || null,
                      timestamp: v.timestamp || Date.now()
                    });
                    console.info("Video subido y actualizado local:", publicUrl);
                  } catch (err) { console.error("Error subiendo video local:", err); }
                } else if (v.file && !v.synced) {
                  // if stored as File object in IDB
                  try {
                    const file = v.file;
                    const { publicUrl, path } = await uploadFileToStorage(VIDEOS_BUCKET, file);
                    v.blob = publicUrl; v.remote_url = publicUrl; v.remote_path = path; v.synced = true; store.put(v);
                    createRemoteVideoRecord({ title: v.title || 'Untitled', url: publicUrl, remote_path: path, type: v.type || 'video', author: v.author, email: v.email, pfp: v.pfp, color: v.color, timestamp: v.timestamp || Date.now() });
                    console.info("Video file subido y actualizado local:", publicUrl);
                  } catch(err){ console.error("Error subiendo file:", err); }
                }
              }
            };
          } catch (err) { console.error("syncLocalVideos error:", err); }
        }

        async function syncLocalStories(db) {
          try {
            const tx = db.transaction("stories", "readwrite");
            const store = tx.objectStore("stories");
            store.getAll().onsuccess = async (e) => {
              const list = e.target.result || [];
              for (const s of list) {
                if (s.img && typeof s.img === 'string' && s.img.startsWith('data:') && !s.synced) {
                  try {
                    const blob = dataURLtoBlob(s.img);
                    const file = new File([blob], `story_${Date.now()}.png`, { type: blob.type || 'image/png' });
                    const { publicUrl, path } = await uploadFileToStorage(STORIES_BUCKET, file);
                    s.img = publicUrl; s.remote_url = publicUrl; s.remote_path = path; s.synced = true; store.put(s);
                    createRemoteStoryRecord({ img: publicUrl, remote_path: path, author: s.author || (user && user.name) || null, email: s.email || (user && user.email) || null, pfp: s.pfp || (user && user.pfp) || null, color: s.color || (user && user.color) || null, created: s.created || Date.now() });
                    console.info("Story subido y actualizado local:", publicUrl);
                  } catch (err) { console.error("Error subiendo story:", err); }
                }
              }
            };
          } catch (err) { console.error("syncLocalStories error:", err); }
        }

        function hookFileInputs() {
          const vf = document.getElementById('vFile');
          if (vf) {
            vf.addEventListener('change', async (ev) => {
              const file = ev.target.files[0];
              if (!file) return;
              try {
                const dbRef = await waitForDB();
                // if supabase available, upload first
                if(supabase){
                  const { publicUrl, path } = await uploadFileToStorage(VIDEOS_BUCKET, file);
                  const vid = { title: (document.getElementById('vTitle')?.value) || file.name, blob: publicUrl, remote_url: publicUrl, remote_path: path, type: (document.getElementById('vT')?.value) || 'video', author: user ? user.name : 'anon', email: user ? user.email : null, pfp: user ? user.pfp : null, color: user ? user.color : null, likedBy: [], comms: [], timestamp: Date.now(), synced: true };
                  dbRef.transaction("videos", "readwrite").objectStore("videos").add(vid).onsuccess = () => {
                    createRemoteVideoRecord({ title: vid.title, url: publicUrl, remote_path: path, type: vid.type, author: vid.author, email: vid.email, pfp: vid.pfp, color: vid.color, timestamp: vid.timestamp });
                    console.info("Bridge: video guardado local con URL:", publicUrl);
                    // refresh UI
                    setTimeout(()=>{ if(typeof renderHome==='function') renderHome(); },400);
                  };
                } else {
                  // fallback: save File into IDB
                  const vid = { title: file.name, blob:null, file: file, type: 'video', author:user?user.name:'anon', email:user?user.email:null, pfp:user?user.pfp:null, color:user?user.color:null, likedBy:[], comms:[], timestamp:Date.now(), synced:false };
                  dbRef.transaction("videos","readwrite").objectStore("videos").add(vid).onsuccess = ()=>{ console.info("Bridge: video guardado local (no supabase)."); setTimeout(()=>{ if(typeof renderHome==='function') renderHome(); },300); };
                }
              } catch (err) {
                console.error("Error subiendo en hook vFile:", err);
              }
            }, { passive: true });
          }

          const sf = document.getElementById('sFile');
          if (sf) {
            sf.addEventListener('change', async (ev) => {
              const file = ev.target.files[0];
              if (!file) return;
              try {
                const dbRef = await waitForDB();
                if(supabase){
                  const { publicUrl, path } = await uploadFileToStorage(STORIES_BUCKET, file);
                  const story = { img: publicUrl, remote_path: path, author: user ? user.name : 'anon', email: user ? user.email : null, color: user ? user.color : null, pfp: user ? user.pfp : null, created: Date.now(), synced: true };
                  dbRef.transaction("stories", "readwrite").objectStore("stories").add(story).onsuccess = () => {
                    createRemoteStoryRecord({ img: publicUrl, remote_path: path, author: story.author, email: story.email, pfp: story.pfp, color: story.color, created: story.created });
                    console.info("Bridge: story guardada local con URL:", publicUrl);
                    setTimeout(()=>{ if(typeof renderStories==='function') renderStories(); },300);
                  };
                } else {
                  // fallback: store as dataURL quickly
                  const reader = new FileReader();
                  reader.onload = () => {
                    const s = { img: reader.result, author:user?user.name:'anon', email:user?user.email:null, color:user?user.color:null, pfp:user?user.pfp:null, created:Date.now(), synced:false };
                    dbRef.transaction("stories","readwrite").objectStore("stories").add(s).onsuccess = ()=>{ console.info("Bridge: story guardada local (no supabase)."); setTimeout(()=>{ if(typeof renderStories==='function') renderStories(); },300); };
                  };
                  reader.readAsDataURL(file);
                }
              } catch (err) {
                console.error("Error subiendo en hook sFile:", err);
              }
            }, { passive: true });
          }
        }

        async function pushLocalChatsToRemote(db) {
          if(!supabase) return;
          try {
            const tx = db.transaction("chats", "readwrite");
            const store = tx.objectStore("chats");
            store.getAll().onsuccess = async (e) => {
              const all = e.target.result || [];
              for (const m of all) {
                if (!m.synced_remote) {
                  try {
                    await supabase.from('chats').insert([{
                      from: m.from,
                      to: m.to,
                      type: m.type || 'text',
                      content: m.content,
                      timestamp: m.timestamp || Date.now(),
                      seen: !!m.seen
                    }]);
                    m.synced_remote = true;
                    store.put(m);
                  } catch (err) {
                    console.error("pushLocalChatsToRemote insert error:", err);
                  }
                }
              }
            };
          } catch (err) { console.error("pushLocalChatsToRemote error:", err); }
        }

        async function handleRemoteInsertToLocal(db, payload) {
          try {
            const rec = payload.record;
            const tx = db.transaction("chats", "readwrite");
            const store = tx.objectStore("chats");
            store.getAll().onsuccess = (e) => {
              const all = e.target.result || [];
              const exists = all.some(m => (m.timestamp === rec.timestamp && m.from === rec.from && m.to === rec.to && m.content === rec.content));
              if (!exists) {
                const local = { from: rec.from, to: rec.to, type: rec.type, content: rec.content, timestamp: rec.timestamp, seen: rec.seen, synced_remote: true };
                store.add(local);
                if(typeof renderInbox === 'function') setTimeout(()=>renderInbox(),200);
              }
            };
          } catch (err) { console.error("handleRemoteInsertToLocal error:", err); }
        }

        function subscribeToRemoteChats(db) {
          if(!supabase) return;
          try {
            const channel = supabase.channel('public:chats')
              .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'chats' }, payload => {
                const rec = payload.record;
                if (user && (rec.to === user.email || rec.from === user.email)) {
                  handleRemoteInsertToLocal(db, payload);
                }
              })
              .subscribe(status => {
                if (status === 'SUBSCRIBED') console.info("Bridge: suscrito a chats remotos");
              });
            window._nexus_bridge_channel = channel;
          } catch (err) { console.error("subscribeToRemoteChats error:", err); }
        }

        async function setPresenceOnline() {
          if (!user || !supabase) return;
          try {
            await supabase.from('presence').upsert([{ email: user.email, last_online: new Date().toISOString(), online: true }]);
            window.addEventListener('beforeunload', async () => {
              await supabase.from('presence').upsert([{ email: user.email, last_online: new Date().toISOString(), online: false }]);
            });
          } catch (err) { console.error("setPresenceOnline error:", err); }
        }

        async function startBridge() {
          try {
            const dbRef = await waitForDB();
            hookFileInputs();
            syncLocalVideos(dbRef);
            syncLocalStories(dbRef);
            pushLocalChatsToRemote(dbRef);
            subscribeToRemoteChats(dbRef);
            setPresenceOnline();
            setInterval(() => syncLocalVideos(dbRef), POLL_INTERVAL_MS);
            setInterval(() => syncLocalStories(dbRef), POLL_INTERVAL_MS);
            setInterval(() => pushLocalChatsToRemote(dbRef), POLL_INTERVAL_MS);
            console.info("Nexus bridge iniciado. Pollers activos.");
          } catch (err) { console.error("startBridge error:", err); }
        }

        async function ensureRemoteUserRow() {
          if (!user || !supabase) return;
          try {
            const { data } = await supabase.from('users').select('*').eq('email', user.email).limit(1);
            if (!data || data.length === 0) {
              await supabase.from('users').insert([{ email: user.email, name: user.name, pfp: user.pfp || null, color: user.color || null, created_at: new Date().toISOString() }]);
            }
          } catch (err) { console.error("ensureRemoteUserRow error:", err); }
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', async () => { await ensureRemoteUserRow(); startBridge(); });
        } else {
          (async () => { await ensureRemoteUserRow(); startBridge(); })();
        }

        // expose useful bits for the app
        window.nexus_bridge = { supabase, uploadFileToStorage, syncLocalVideos, syncLocalStories, pushLocalChatsToRemote, subscribeToRemoteChats, createRemoteVideoRecord, createRemoteStoryRecord, config: { VIDEOS_BUCKET, STORIES_BUCKET } };
      })();
    } // end guard
    </script>

</body>
</html>